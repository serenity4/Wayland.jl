module LibWayland

using ..Wayland: Wayland

# using Wayland_jll: libwayland_client, libwayland_cursor, libwayland_egl, libwayland_server
using CEnum
using BitMasks

# Use system libs for now.
const libwayland_client = Symbol("libwayland-client")
const libwayland_cursor = Symbol("libwayland-cursor")
const libwayland_egl = Symbol("libwayland-egl")
const libwayland_server = Symbol("libwayland-server")

const IS_LIBC_MUSL = occursin("musl", Base.BUILD_TRIPLET)

const wl_object = Cvoid

# We don't include the protocol headers generated by wayland-scanner,
# so we need to include these opaque types manually.
# They can be copy-pasted from the struct definitions at `$(Wayland_jll.artifact_dir)/include/wayland-client-protocol.h`.
const wl_buffer = Cvoid
const wl_callback = Cvoid
const wl_compositor = Cvoid
const wl_data_device = Cvoid
const wl_data_device_manager = Cvoid
const wl_data_offer = Cvoid
const wl_data_source = Cvoid
const wl_display = Cvoid
const wl_keyboard = Cvoid
const wl_output = Cvoid
const wl_pointer = Cvoid
const wl_region = Cvoid
const wl_registry = Cvoid
const wl_seat = Cvoid
const wl_shell = Cvoid
const wl_shell_surface = Cvoid
const wl_shm = Cvoid
const wl_shm_pool = Cvoid
const wl_subcompositor = Cvoid
const wl_subsurface = Cvoid
const wl_surface = Cvoid
const wl_touch = Cvoid

if Sys.isapple() && Sys.ARCH === :aarch64
    include("../lib/aarch64-apple-darwin20.jl")
elseif Sys.islinux() && Sys.ARCH === :aarch64 && !IS_LIBC_MUSL
    include("../lib/aarch64-linux-gnu.jl")
elseif Sys.islinux() && Sys.ARCH === :aarch64 && IS_LIBC_MUSL
    include("../lib/aarch64-linux-musl.jl")
elseif Sys.islinux() && startswith(string(Sys.ARCH), "arm") && !IS_LIBC_MUSL
    include("../lib/armv7l-linux-gnueabihf.jl")
elseif Sys.islinux() && startswith(string(Sys.ARCH), "arm") && IS_LIBC_MUSL
    include("../lib/armv7l-linux-musleabihf.jl")
elseif Sys.islinux() && Sys.ARCH === :i686 && !IS_LIBC_MUSL
    include("../lib/i686-linux-gnu.jl")
elseif Sys.islinux() && Sys.ARCH === :i686 && IS_LIBC_MUSL
    include("../lib/i686-linux-musl.jl")
elseif Sys.iswindows() && Sys.ARCH === :i686
    include("../lib/i686-w64-mingw32.jl")
elseif Sys.islinux() && Sys.ARCH === :powerpc64le
    include("../lib/powerpc64le-linux-gnu.jl")
elseif Sys.isapple() && Sys.ARCH === :x86_64
    include("../lib/x86_64-apple-darwin14.jl")
elseif Sys.islinux() && Sys.ARCH === :x86_64 && !IS_LIBC_MUSL
    include("../lib/x86_64-linux-gnu.jl")
elseif Sys.islinux() && Sys.ARCH === :x86_64 && IS_LIBC_MUSL
    include("../lib/x86_64-linux-musl.jl")
elseif Sys.isbsd() && !Sys.isapple()
    include("../lib/x86_64-unknown-freebsd11.1.jl")
elseif Sys.iswindows() && Sys.ARCH === :x86_64
    include("../lib/x86_64-w64-mingw32.jl")
else
    error("Unknown platform: $(Base.BUILD_TRIPLET)")
end

const FPtr = Ptr{Cvoid}

struct Fixed{T}
    val::T
end

Base.convert(::Type{Fixed}, t::Number) = Fixed(t)
Base.convert(::Type{Fixed}, t::Fixed) = t

Base.cconvert(::Type{wl_fixed_t}, t::Fixed{<:AbstractFloat}) = wl_fixed_from_double(convert(Cdouble, t.val))
Base.cconvert(::Type{wl_fixed_t}, t::Fixed{<:Integer}) = wl_fixed_from_int(convert(Cint, t.val))

abstract type ListenerCallbacks end

"""
    Listener(proxy, callbacks::ListenerCallbacks, data = nothing)

Create a listener object which ensures that all the memory used by a set of callbacks will remain valid
as long as the listener is valid.

User-provided data may be:
- `nothing` (default), in which case the user data provided to Wayland will be `C_NULL`.
- `Ptr`, in which case it will be assumed that the pointer will remain valid. Loads to this data should be done manually by the user
  in the callback code, as [`retrieve_data`](@ref) makes a few assumptions as to how the pointer was obtained.
- Mutable data, in which case its pointer will obtained via `pointer_from_objref` and [`retrieve_data`](@ref) will use `unsafe_pointer_to_objref`.
- Immutable data, in which case a `Ref` will wrap the data and a pointer to this reference will be passed in as user data. Loads with `retrieve_data` will
  use `Base.unsafe_load`.

For the callbacks to be active, you must [`register`](@ref) the listener. Read the documentation of [`register`](@ref) carefully for more information about
managing the listener's lifetime, which is vital in order for the callbacks not to cause undefined behavior.
"""
mutable struct Listener
    proxy::Ptr{wl_proxy}
    callbacks::Base.RefValue{ListenerCallbacks}
    dataref::Any
    dataptr::Ptr{Cvoid}
    function Listener(proxy, callbacks::ListenerCallbacks, data = nothing)
        dataref = data_reference(data)
        dataptr = get_dataptr(data)
        l = new(proxy, Ref{ListenerCallbacks}(callbacks), dataref, dataptr)
        finalizer(l) do x
            # Unset it from the set of active listeners so that the object can be garbage-collected.
            @lock active_listeners.lock haskey(active_listeners.dict, x) && delete!(active_listeners.dict, x)
        end
    end
end

data_reference(data::Nothing) = data
data_reference(data::Ptr) = data
data_reference(data::T) where {T} = ismutabletype(T) ? data : Ref(data)

get_dataptr(data::Nothing) = C_NULL
get_dataptr(data::Ptr) = data
get_dataptr(data::Base.RefValue{T}) where {T} = Ptr{Cvoid}(Base.unsafe_convert(Ptr{T}, data))
function get_dataptr(data::T) where {T}
    @assert ismutabletype(T)
    pointer_from_objref(data)
end

"""
Retrieve data from a pointer, assuming that it is derived from the provided type.

`data` must not be null, will be assumed to point to valid memory and will be assumed to have been handled by `data_reference` and `get_dataptr`.
If `data` was provided as a pointer to a [`Listener`](@ref), 
"""
function retrieve_data(data, ::Type{T}) where {T}
    data == C_NULL && return error("Attempt to retrieve data from a null pointer.")
    ismutabletype(T) ? unsafe_pointer_to_objref(data)::T : Base.unsafe_load(Ptr{T}(data))
end

Base.cconvert(::Type{Ptr{Ptr{Cvoid}}}, l::Listener) = l.callbacks
Base.unsafe_convert(T::Type{Ptr{Ptr{Cvoid}}}, ref::Base.RefValue{ListenerCallbacks}) = T(Base.unsafe_convert(Ptr{ListenerCallbacks}, ref))

mutable struct ActiveListeners
    lock::Threads.SpinLock
    dict::IdDict{Listener,Nothing}
    has_warned::Bool
end

function Base.empty!(listeners::ActiveListeners)
    empty!(listeners.dict)
    listeners.has_warned = false
end

# Prevent these listeners from being garbage-collected.
const active_listeners = ActiveListeners(Threads.SpinLock(), IdDict{Listener,Nothing}(), false)


function keep_alive(listener::Listener)
    @lock active_listeners.lock begin
        (; dict) = active_listeners
        if !active_listeners.has_warned && length(dict) > 1000
            @warn "More than 1000 listeners are being kept alive - this may be a sign of an unhandled memory leak. Listeners allocated on a frequent basis should be manually kept alive or killed after use by explicitly calling `finalize(listener)`."
            active_listeners.has_warned = true
        end
        dict[listener] = nothing
    end
end

"""
Register a listener with optional user-data `data`.

If `keep_alive` is set to true (default), then the listener will be kept on a global concurrent data structure
to prevent it from being garbage-collected. You can manually remove the listener from this state by calling
`finalize(listener)` (which will be a no-op if the listener was never preserved via a call to `register(..., `keep_alive = true`)`.

!!! danger
    `keep_alive = false` should be used with care; the listener must be kept alive as long as the callback may be fired
    by the Wayland server. The most robust way to accomplish this is by storing the callback in a parent data structure or by using `GC.@preserve` if
    the listener is known to be called during a set of statements.

!!! danger
    `keep_alive = true` will keep the listener alive indefinitely, effectively resulting in a memory leak. For one-time listeners, that is generally fine - but if
    you create lots of such listeners (e.g. one per frame), it may end up eating up a lot of memory. In this case, you should manually keep it alive or killed
    after use by explicitly calling `finalize(listener)` when you know its callback will never be invoked again.
"""
function register(listener::Listener; keep_alive = true)
    wl_proxy_add_listener(listener.proxy, listener.callbacks, listener.dataptr)
    keep_alive && @__MODULE__().keep_alive(listener)
    listener
end

listen(proxy, callbacks::ListenerCallbacks, data = nothing; keep_listener_alive = true) = register(Listener(proxy, callbacks, data); keep_alive = keep_listener_alive)

include("../lib/enums.jl")
include("../lib/listeners.jl")
include("../lib/functions.jl")

# Exports.

export Listener, ListenerCallbacks, retrieve_data

all_prefixes(x) = [uppercase(x) * '_', x, uppercasefirst(x), "@cfunction_" * x]

const PREFIXES = foldl(vcat, all_prefixes.(["wl", "xdg", "wp"]))
for name in names(@__MODULE__; all=true), prefix in PREFIXES
    if startswith(string(name), prefix)
        @eval export $name
    end
end

end
